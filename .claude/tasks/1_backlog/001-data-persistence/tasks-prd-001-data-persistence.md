# Task Breakdown for PRD-001: Data Persistence & Enhanced Customization

## Overview

This task list implements data persistence and unlimited vocabulary expansion for the AAC Communication Board, transforming it from a session-based prototype into a reliable, personalized communication tool with offline-first capabilities.

## Relevant Files

### New Files to Create

**Data Layer**
- `application/src/lib/db/schema.ts` - TypeScript interfaces for IndexedDB data models (Word, Category, Settings, Resource, Metadata)
- `application/src/lib/db/dataService.ts` - IndexedDB abstraction layer using Dexie.js (CRUD operations, queries)
- `application/src/lib/db/migrationService.ts` - Data schema versioning and migration utilities
- `application/src/lib/db/dataService.test.ts` - Unit tests for dataService operations
- `application/src/lib/db/migrationService.test.ts` - Unit tests for migration logic

**Image Handling**
- `application/src/components/ImageUploader.tsx` - Image upload UI with drag-and-drop, preview, and crop
- `application/src/lib/utils/imageProcessor.ts` - Client-side image compression, resize, and base64 conversion utilities
- `application/src/components/ImageUploader.test.tsx` - Unit tests for ImageUploader component
- `application/src/lib/utils/imageProcessor.test.ts` - Unit tests for image processing utilities

**Import/Export**
- `application/src/components/ImportExportManager.tsx` - Import/export UI with merge strategies and conflict resolution
- `application/src/lib/utils/exportService.ts` - Export vocabulary to JSON with metadata
- `application/src/lib/utils/importService.ts` - Import vocabulary from JSON with validation and merge strategies
- `application/src/components/ImportExportManager.test.tsx` - Unit tests for import/export UI
- `application/src/lib/utils/exportService.test.ts` - Unit tests for export functionality
- `application/src/lib/utils/importService.test.ts` - Unit tests for import functionality

**Offline Support**
- `application/src/components/OfflineIndicator.tsx` - Online/offline status indicator component
- `application/public/service-worker.js` - Service worker for offline caching (generated by vite-plugin-pwa)
- `application/src/components/OfflineIndicator.test.tsx` - Unit tests for offline indicator

**Testing Infrastructure**
- `application/src/setupTests.ts` - Test setup and mock configurations for IndexedDB
- `application/src/lib/db/testUtils.ts` - Test utilities for database operations (factories, seed data)

### Files to Modify

**Core Application**
- `application/src/App.tsx` - Refactor state management to load/save from IndexedDB instead of in-memory state
- `application/src/components/settings/EditWordsScreen.tsx` - Add unlimited word addition, category creation, image upload integration
- `application/src/components/settings/ColorThemeScreen.tsx` - Auto-save color changes to IndexedDB
- `application/src/components/SettingsScreen.tsx` - Add "Backup & Restore" section for import/export
- `application/src/components/ResourcesScreen.tsx` - Save custom resources to IndexedDB
- `application/src/components/WordButton.tsx` - Support custom images with lazy loading
- `application/package.json` - Add new dependencies (dexie, vite-plugin-pwa, react-dropzone, react-image-crop, browser-image-compression, @testing-library packages)
- `application/vite.config.ts` - Configure vite-plugin-pwa for service worker generation

**Type Definitions**
- `application/src/App.tsx` - Extend Word and Category interfaces to match IndexedDB schema (add id, order, timestamps, customImageUrl fields)

### Notes

- All TypeScript files should have corresponding `.test.ts` or `.test.tsx` files for TDD workflow
- Unit tests should be placed alongside the code files they test (same directory)
- Use `npm test` to run all tests via Vitest (Vite's test runner)
- IndexedDB operations should be wrapped in try-catch with proper error handling
- Service worker configuration handled by vite-plugin-pwa (no manual service worker code initially)

---

## Tasks

### Phase 1A: IndexedDB Foundation (Week 1)

- [ ] 1.0 Set up IndexedDB infrastructure with Dexie.js and define data schema
  - **Assigned Agent**: tactical-software-engineer
  - **Context**: Establish the foundational data persistence layer using IndexedDB with Dexie.js wrapper. This is the core requirement that all other features depend on. The agent will define TypeScript interfaces matching the PRD schema, implement the DataService abstraction layer for CRUD operations, and create migration utilities for schema versioning. This task requires deep TypeScript knowledge, understanding of browser APIs, and database design skills.

  **Sub-Tasks**:

  - [ ] 1.1 Install Dexie.js dependency and configure build tooling
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write test to verify Dexie.js imports successfully and can initialize a test database
    - **Files to Create**: `application/src/lib/db/dexie.test.ts`
    - **Files to Modify**: `application/package.json` (add dexie@^4.0.0, @types/dexie)
    - **Success Criteria**: `npm install` completes successfully, test imports Dexie without errors

  - [ ] 1.2 Define TypeScript interfaces for IndexedDB schema (Word, Category, Settings, Resource, Metadata)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to validate TypeScript interface structure and type safety
    - **Files to Create**: `application/src/lib/db/schema.ts`, `application/src/lib/db/schema.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: All interfaces match PRD schema, tests validate required fields and types
    - **Details**: Word interface must include `id: string (UUID)`, `text: string`, `icon: string`, `type: WordType`, `categoryId?: string`, `order: number`, `customImageUrl?: string`, `createdAt: Date`, `updatedAt: Date`. Category interface must include `id: string`, `name: string`, `parentId?: string`, `order: number`, `depth: number (0-2)`, `createdAt: Date`, `updatedAt: Date`.

  - [ ] 1.3 Implement Dexie database class with schema version 1
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify database initialization, table creation, and schema versioning
    - **Files to Create**: `application/src/lib/db/database.ts`, `application/src/lib/db/database.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Database initializes with correct schema, version 1 configured, all tables created
    - **Details**: Create `AACDatabase` class extending `Dexie`, define stores for `words`, `categories`, `settings`, `resources`, `metadata`. Use schema syntax: `++id, text, type, categoryId, order` for words table, etc.

  - [ ] 1.4 Implement DataService CRUD operations (create, read, update, delete) for words
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write comprehensive unit tests for all CRUD operations (create, getById, getAll, update, delete)
    - **Files to Create**: `application/src/lib/db/dataService.ts`, `application/src/lib/db/dataService.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: All CRUD operations complete in <100ms for typical datasets, tests achieve >90% coverage
    - **Details**: Implement methods: `createWord(word)`, `getWord(id)`, `getAllWords()`, `getWordsByCategory(categoryId)`, `updateWord(id, updates)`, `deleteWord(id)`. Each method should use try-catch, return proper types, handle errors gracefully.

  - [ ] 1.5 Implement DataService CRUD operations for categories, settings, resources
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests for category CRUD, settings get/set, and resource CRUD operations
    - **Files to Create**: None (extend dataService.ts and dataService.test.ts)
    - **Files to Modify**: `application/src/lib/db/dataService.ts`, `application/src/lib/db/dataService.test.ts`
    - **Success Criteria**: Category hierarchy supports up to 3 levels, settings persistence validated, all operations tested
    - **Details**: Category methods: `createCategory(category)`, `getCategory(id)`, `getAllCategories()`, `getCategoryChildren(parentId)`, `updateCategory(id, updates)`, `deleteCategory(id)`. Settings methods: `getSetting(key)`, `setSetting(key, value)`. Resource methods: `createResource(resource)`, `getResource(id)`, `getAllResources()`, `updateResource(id, updates)`, `deleteResource(id)`.

  - [ ] 1.6 Implement data seeding service for baseline vocabulary (139 words, 7 categories)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify baseline data seeds correctly on first load and doesn't duplicate on subsequent loads
    - **Files to Create**: `application/src/lib/db/seedService.ts`, `application/src/lib/db/seedService.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Baseline vocabulary seeds in <500ms, idempotent (safe to run multiple times), maintains current vocabulary from App.tsx
    - **Details**: Implement `seedBaselineVocabulary()` method that checks if database is empty (no categories or words), then populates with 7 categories (People, Food, Places, Feelings, Actions, School, Weather) and 139 words from existing `initialCoreWords` and `initialCategoryWords` in App.tsx. Use transactions for atomic operations.

  - [ ] 1.7 Implement database migration service for schema versioning
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify migration from schema v1 to v2 (simulated future migration)
    - **Files to Create**: `application/src/lib/db/migrationService.ts`, `application/src/lib/db/migrationService.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Migration framework supports adding new fields, tests validate data preservation across migrations
    - **Details**: Implement migration handler using Dexie's `.upgrade()` method. Create migration registry pattern to support future schema changes. Initial migration should be v1 → v2 (no-op for now, but establishes pattern). Document migration best practices.

  - [ ] 1.8 Create test utilities and mock database for testing
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests using the test utilities to verify they work correctly
    - **Files to Create**: `application/src/lib/db/testUtils.ts`, `application/src/lib/db/testUtils.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Test utilities provide factory methods for test data, mock database works in test environment
    - **Details**: Implement factory functions for creating test Words, Categories, Settings, Resources. Create `createMockDatabase()` helper that initializes in-memory Dexie database for tests. Provide `seedTestData()` function with sample vocabulary for integration tests.

- [ ] 2.0 Migrate App.tsx state management from in-memory to IndexedDB persistence
  - **Assigned Agent**: tactical-software-engineer
  - **Context**: Refactor the core application state management to load initial data from IndexedDB and auto-save all changes. This requires understanding React state patterns, async initialization, and integration with the DataService layer. The agent will need to handle loading states, fallback to baseline vocabulary on first load, and ensure zero data loss across browser sessions.

  **Sub-Tasks**:

  - [ ] 2.1 Extend Word and Category interfaces in App.tsx to match IndexedDB schema
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to ensure type compatibility between App.tsx interfaces and schema.ts interfaces
    - **Files to Create**: `application/src/App.test.tsx` (if not exists)
    - **Files to Modify**: `application/src/App.tsx`
    - **Success Criteria**: Word interface includes id, order, timestamps, customImageUrl; Category interface includes id, parentId, depth, order, timestamps
    - **Details**: Add to Word interface: `id: string`, `categoryId?: string`, `order: number`, `customImageUrl?: string`, `createdAt?: Date`, `updatedAt?: Date`. Add to CategoryWord interface: `id: string`, `order: number`, `createdAt?: Date`, `updatedAt?: Date`. Create new Category interface: `id: string`, `name: CategoryName`, `parentId?: string`, `order: number`, `depth: number`, `createdAt: Date`, `updatedAt: Date`.

  - [ ] 2.2 Implement async initialization hook to load data from IndexedDB on app mount
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify data loads from IndexedDB on mount, handles loading state, and falls back to seeding on first load
    - **Files to Create**: None
    - **Files to Modify**: `application/src/App.tsx`, `application/src/App.test.tsx`
    - **Success Criteria**: App loads persisted data in <300ms, displays loading indicator during initialization, seeds baseline vocabulary on first load
    - **Details**: Create `useEffect` hook that runs on mount to call `dataService.getAllWords()` and `dataService.getAllCategories()`. Add loading state (`isInitializing: boolean`). Display loading spinner while `isInitializing === true`. If database is empty, call `seedService.seedBaselineVocabulary()` then reload data.

  - [ ] 2.3 Refactor state setters to persist changes to IndexedDB immediately
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify all state changes trigger IndexedDB updates and data persists correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/src/App.tsx`, `application/src/App.test.tsx`
    - **Success Criteria**: Word additions/updates/deletes persist to IndexedDB, category changes persist, no race conditions in concurrent updates
    - **Details**: Wrap all state setters (e.g., `setCoreWords`, `setCategoryWords`) with IndexedDB persistence calls. For example, when adding a word, call `dataService.createWord(word)` then update React state. When updating a word, call `dataService.updateWord(id, updates)` then update state. Use async/await pattern to ensure persistence completes before state update.

  - [ ] 2.4 Implement optimistic UI updates with rollback on persistence failure
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify optimistic updates occur immediately and rollback on database errors
    - **Files to Create**: None
    - **Files to Modify**: `application/src/App.tsx`, `application/src/App.test.tsx`
    - **Success Criteria**: UI updates instantly (optimistic), rolls back and displays error if IndexedDB write fails, retry mechanism for transient failures
    - **Details**: Implement optimistic update pattern: (1) Update React state immediately for instant UI feedback, (2) Attempt IndexedDB write in background, (3) If write fails, revert React state and display error toast, (4) Provide "Retry" button in error toast to attempt write again.

  - [ ] 2.5 Add error boundary for database initialization failures
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify error boundary catches database errors and displays fallback UI
    - **Files to Create**: `application/src/components/ErrorBoundary.tsx`, `application/src/components/ErrorBoundary.test.tsx`
    - **Files to Modify**: `application/src/main.tsx` (wrap App in ErrorBoundary)
    - **Success Criteria**: Database errors caught gracefully, user sees helpful error message with recovery options (clear storage, refresh)
    - **Details**: Create React ErrorBoundary component that catches errors during initialization. Display user-friendly error message: "We couldn't load your vocabulary. This might be due to browser storage issues." Provide buttons: "Clear Storage & Reload" (clears IndexedDB and refreshes), "Reload Page" (just refreshes).

- [ ] 3.0 Implement auto-save functionality with visual feedback for all user changes
  - **Assigned Agent**: tactical-ux-ui-designer
  - **Context**: Design and implement the user-facing persistence feedback system (saving indicators, success confirmations, error messages). This requires UX design skills to create non-intrusive feedback that builds user trust in the data persistence system. The agent will create visual indicators for "Saving...", "Saved ✓", and error states with retry options.

  **Sub-Tasks**:

  - [ ] 3.1 Design auto-save status indicator component (Saving..., Saved ✓, Error states)
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write visual regression tests for status indicator component states
    - **Files to Create**: `application/src/components/AutoSaveIndicator.tsx`, `application/src/components/AutoSaveIndicator.test.tsx`
    - **Files to Modify**: None
    - **Success Criteria**: Indicator displays correctly in all 3 states (saving, saved, error), uses accessible colors, non-intrusive positioning
    - **Details**: Create component with 3 visual states: (1) "Saving..." with spinner icon (blue), (2) "Saved ✓" with checkmark icon (green, auto-dismiss after 2s), (3) "Error saving" with alert icon (red, persistent until retry/dismiss). Position in top-right corner of screen with subtle fade-in/out animation. Use Lucide icons: Loader2 (spinning), Check, AlertCircle.

  - [ ] 3.2 Implement auto-save hook to debounce rapid changes and trigger save indicator
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify debouncing works correctly and save indicator state updates appropriately
    - **Files to Create**: `application/src/hooks/useAutoSave.ts`, `application/src/hooks/useAutoSave.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Changes debounced to max 1 save per 500ms, indicator state managed correctly, no unnecessary re-renders
    - **Details**: Create custom React hook `useAutoSave(value, saveFn, debounceMs = 500)` that debounces value changes and calls saveFn. Returns `{ status: 'idle' | 'saving' | 'saved' | 'error', retry: () => void }`. Uses `useDebounce` or `useDebouncedCallback` pattern. Implements exponential backoff for retry logic.

  - [ ] 3.3 Integrate auto-save indicator into Settings screens (Edit Words, Color Theme)
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write integration tests to verify indicator appears and updates correctly when settings change
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx`, `application/src/components/settings/ColorThemeScreen.tsx`
    - **Success Criteria**: Indicator shows "Saving..." when settings change, transitions to "Saved ✓" on success, shows error state on failure
    - **Details**: Import and render `<AutoSaveIndicator />` component in settings screens. Connect to `useAutoSave` hook wrapping word/category updates and color theme changes. Ensure indicator is positioned consistently across both screens.

  - [ ] 3.4 Design error toast notification with retry and dismiss actions
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify toast appears on errors, retry button works, dismiss button works
    - **Files to Create**: `application/src/components/ErrorToast.tsx`, `application/src/components/ErrorToast.test.tsx`
    - **Files to Modify**: None
    - **Success Criteria**: Toast appears on persistence errors, includes helpful error message, provides Retry and Dismiss buttons
    - **Details**: Create toast component using Shadcn toast/sonner. Display error message: "We couldn't save your changes. [Error details]". Include two action buttons: "Retry" (attempts save again), "Dismiss" (closes toast). Toast should persist until user action (no auto-dismiss for errors). Use red color scheme for error severity.

  - [ ] 3.5 Implement global error toast manager for database operation failures
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify error toast manager captures errors and displays toasts correctly
    - **Files to Create**: `application/src/lib/errorManager.ts`, `application/src/lib/errorManager.test.ts`
    - **Files to Modify**: `application/src/App.tsx` (integrate error manager)
    - **Success Criteria**: All database errors trigger error toasts, toast manager provides retry mechanism, errors logged for debugging
    - **Details**: Create error manager singleton that wraps database operations with try-catch. On error, triggers ErrorToast and logs error to console. Provides `retryLastOperation()` method for retry button. Integrates with `useAutoSave` hook to coordinate retry logic.

### Phase 1B: Unlimited Vocabulary Expansion (Week 2)

- [ ] 4.0 Enable unlimited word and category creation beyond hardcoded limits
  - **Assigned Agent**: tactical-software-engineer
  - **Context**: Remove all hardcoded word and category limits from the application, implementing dynamic data structures that scale with IndexedDB storage. This includes adding UUID generation for new entities, implementing word ordering within categories, and supporting nested category hierarchies up to 3 levels. The agent will ensure performance remains acceptable with 500+ custom words.

  **Sub-Tasks**:

  - [ ] 4.1 Install UUID generation library and implement utility functions
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify UUID generation produces valid v4 UUIDs and no collisions
    - **Files to Create**: `application/src/lib/utils/uuid.ts`, `application/src/lib/utils/uuid.test.ts`
    - **Files to Modify**: `application/package.json` (add uuid@^10.0.0, @types/uuid)
    - **Success Criteria**: UUID generation works correctly, generates RFC 4122 compliant UUIDs
    - **Details**: Install `uuid` package. Create wrapper function `generateId(): string` that uses `uuidv4()`. Add validation function `isValidUUID(id: string): boolean` for testing.

  - [ ] 4.2 Remove hardcoded word limits and implement dynamic word creation
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify users can create unlimited words and all words persist correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/src/App.tsx`, `application/src/components/settings/EditWordsScreen.tsx`
    - **Success Criteria**: No maximum word count enforced, new words get unique IDs and correct ordering, performance acceptable with 500+ words
    - **Details**: Remove any max word count checks. When adding a word, generate UUID for `id` field, calculate `order` as max(existing orders) + 1, set timestamps. Ensure word lists dynamically expand based on database content.

  - [ ] 4.3 Implement category hierarchy support (up to 3 levels deep)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify 3-level category hierarchies work correctly and 4th level is prevented
    - **Files to Create**: `application/src/lib/utils/categoryHelpers.ts`, `application/src/lib/utils/categoryHelpers.test.ts`
    - **Files to Modify**: `application/src/lib/db/dataService.ts` (add category depth validation)
    - **Success Criteria**: Categories can nest up to 3 levels, 4th level creation prevented with error message, depth calculated correctly
    - **Details**: Implement `getCategoryDepth(categoryId)` function that traverses parentId chain to calculate depth. Implement `canAddSubcategory(categoryId): boolean` that returns false if depth >= 2. Add validation in `createCategory()` to enforce depth limit.

  - [ ] 4.4 Implement word reordering within categories
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify reordering updates order field correctly and persists to database
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/db/dataService.ts` (add reorderWords method)
    - **Success Criteria**: Words can be reordered within categories, order field updates correctly, reordering persists across sessions
    - **Details**: Implement `reorderWords(categoryId, wordIds: string[])` method that updates `order` field for all words in the category based on new array position. Use transaction to ensure atomic update. Return updated words.

  - [ ] 4.5 Implement category reordering
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify category reordering works correctly and persists
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/db/dataService.ts` (add reorderCategories method)
    - **Success Criteria**: Categories can be reordered at same hierarchy level, order persists, child categories maintain correct relationships
    - **Details**: Implement `reorderCategories(parentId, categoryIds: string[])` method that updates `order` field for categories with same parentId. Ensure child categories not affected by parent reordering.

- [ ] 5.0 Implement word and category management UI (add, edit, delete, reorder)
  - **Assigned Agent**: tactical-ux-ui-designer
  - **Context**: Design and implement intuitive UI controls for vocabulary management including inline editing, drag-and-drop reordering (desktop) with up/down arrows (mobile), category creation, and delete confirmations. This requires strong UX skills to make complex operations accessible to users with varying technical abilities, including consideration for motor skill limitations.

  **Sub-Tasks**:

  - [ ] 5.1 Design and implement "Add Word" UI with icon picker
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write component tests to verify add word form validates inputs and calls create function
    - **Files to Create**: `application/src/components/AddWordDialog.tsx`, `application/src/components/AddWordDialog.test.tsx`, `application/src/components/IconPicker.tsx`, `application/src/components/IconPicker.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (add button to open dialog)
    - **Success Criteria**: Dialog allows entering word text, selecting icon from Lucide library, choosing word type, selecting category
    - **Details**: Create dialog with form fields: text input (required, max 20 chars), icon picker (searchable Lucide icon grid), word type dropdown (pronoun/verb/descriptive/noun/social), category selector (dropdown with hierarchy). Validate text is not empty before allowing save.

  - [ ] 5.2 Design and implement inline word editing
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify inline editing activates on click and saves on blur/enter
    - **Files to Create**: `application/src/components/EditableWordButton.tsx`, `application/src/components/EditableWordButton.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (use EditableWordButton instead of WordButton)
    - **Success Criteria**: Click word to edit inline, press Enter or blur to save, Escape to cancel, changes persist to database
    - **Details**: Create component that switches between display mode (looks like WordButton) and edit mode (inline text input + icon picker). Use `contentEditable` or input overlay. Auto-save on blur or Enter keypress. Cancel on Escape.

  - [ ] 5.3 Implement delete confirmation dialog with undo option
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify delete confirmation appears and undo works correctly
    - **Files to Create**: `application/src/components/DeleteConfirmDialog.tsx`, `application/src/components/DeleteConfirmDialog.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (add delete button to words)
    - **Success Criteria**: Delete shows confirmation dialog, confirmation deletes word, undo toast appears for 5s with restore option
    - **Details**: Create confirmation dialog: "Delete '[word text]'? This cannot be undone." with Cancel and Delete buttons. After deletion, show toast: "Word deleted" with "Undo" button (available for 5 seconds). Undo restores word to database.

  - [ ] 5.4 Design drag-and-drop reordering for desktop
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify drag-and-drop updates order correctly
    - **Files to Create**: `application/src/components/DraggableWordList.tsx`, `application/src/components/DraggableWordList.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (wrap word list in draggable container)
    - **Success Criteria**: Words draggable on desktop with visual feedback, drop updates order and persists
    - **Details**: Use `@dnd-kit/core` library for drag-and-drop. Show dragging state with opacity/shadow. On drop, call `dataService.reorderWords()`. Add `application/package.json` dependency: `@dnd-kit/core@^6.0.0`.

  - [ ] 5.5 Design up/down arrow reordering for mobile
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify arrow buttons move words correctly
    - **Files to Create**: `application/src/components/ReorderControls.tsx`, `application/src/components/ReorderControls.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (add arrow buttons on mobile)
    - **Success Criteria**: Up/down arrows appear on mobile (< 768px), arrows move words one position, changes persist
    - **Details**: Add up/down arrow buttons (Lucide ArrowUp/ArrowDown icons) next to each word on mobile view. Disable up arrow for first word, down arrow for last word. On click, swap order values with adjacent word and update database.

  - [ ] 5.6 Implement "Add Category" UI with depth validation
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify category creation validates depth limit and shows error
    - **Files to Create**: `application/src/components/AddCategoryDialog.tsx`, `application/src/components/AddCategoryDialog.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (add "Add Category" button)
    - **Success Criteria**: Dialog allows entering category name and selecting parent (if depth < 3), shows error if depth limit reached
    - **Details**: Create dialog with category name input (required, max 30 chars) and parent category selector (optional, dropdown with hierarchy). Validate depth using `categoryHelpers.canAddSubcategory()`. Show error: "Categories can only be 3 levels deep" if limit reached.

  - [ ] 5.7 Design category management UI (edit, delete, move)
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify category operations work correctly and handle words in deleted categories
    - **Files to Create**: `application/src/components/CategoryManager.tsx`, `application/src/components/CategoryManager.test.tsx`
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx` (add category management section)
    - **Success Criteria**: Categories can be renamed, deleted (with word reassignment), moved to different parent
    - **Details**: Create UI showing category tree with actions for each category: Edit (rename), Delete (reassign words to different category or "Uncategorized"), Move (change parent). Deleting category with children should require reassigning or deleting children first.

### Phase 1C: Custom Image Upload & Storage (Week 2-3)

- [ ] 6.0 Build custom image upload system with compression and IndexedDB storage
  - **Assigned Agent**: tactical-software-engineer
  - **Context**: Implement client-side image upload, processing, and storage in IndexedDB. This includes file validation (PNG, JPG, WebP, SVG), size limits (1MB), compression to recommended size (500KB), base64 conversion for storage, and integration with the DataService layer. Requires knowledge of File API, Canvas API for image processing, and performance optimization for large binary data.

  **Sub-Tasks**:

  - [ ] 6.1 Install image processing dependencies (browser-image-compression)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write test to verify library imports and compresses test image correctly
    - **Files to Create**: `application/src/lib/utils/imageProcessor.test.ts`
    - **Files to Modify**: `application/package.json` (add browser-image-compression@^2.0.0)
    - **Success Criteria**: Library installs successfully, can compress sample image to target size
    - **Details**: Install `browser-image-compression` package for client-side image compression. Write basic test that compresses a test image and verifies result is smaller than original.

  - [ ] 6.2 Implement file validation (type, size, dimensions)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify validation accepts valid files and rejects invalid files
    - **Files to Create**: `application/src/lib/utils/imageValidator.ts`, `application/src/lib/utils/imageValidator.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Validates file type (PNG/JPG/WebP/SVG only), max size 1MB, provides helpful error messages
    - **Details**: Implement `validateImageFile(file: File)` function that checks: (1) MIME type is image/png, image/jpeg, image/webp, or image/svg+xml, (2) file size <= 1MB, (3) returns error message if validation fails. Also implement `getImageDimensions(file: File)` to read actual image dimensions.

  - [ ] 6.3 Implement image compression to target size (500KB recommended)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify compression reduces file size to target while maintaining quality
    - **Files to Create**: `application/src/lib/utils/imageProcessor.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Compression reduces files >500KB to ~500KB, maintains acceptable visual quality, handles errors gracefully
    - **Details**: Implement `compressImage(file: File, targetSizeKB = 500)` using browser-image-compression library. Configure options: maxSizeMB (0.5), maxWidthOrHeight (800px for word buttons), useWebWorker (true for performance). Return compressed File object.

  - [ ] 6.4 Implement base64 conversion for IndexedDB storage
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify base64 conversion roundtrip (file → base64 → file) preserves data
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/imageProcessor.ts`, `application/src/lib/utils/imageProcessor.test.ts`
    - **Success Criteria**: Conversion produces valid base64 data URLs, roundtrip conversion preserves image data exactly
    - **Details**: Implement `fileToBase64(file: File): Promise<string>` using FileReader API. Returns data URL string (e.g., "data:image/png;base64,..."). Also implement `base64ToFile(base64: string, filename: string): File` for reverse conversion. Test roundtrip conversion.

  - [ ] 6.5 Integrate image storage with DataService (save to Word records)
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify images save to word records and retrieve correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/db/dataService.ts`, `application/src/lib/db/dataService.test.ts`
    - **Success Criteria**: Word records can store base64 image data in customImageUrl field, images persist across sessions
    - **Details**: Extend `createWord()` and `updateWord()` methods to accept `customImageUrl` field. Store base64 data URL directly in IndexedDB. Add `getWordImage(wordId): Promise<string | null>` helper method. Test that large images (500KB) store and retrieve correctly.

  - [ ] 6.6 Implement image lazy loading in WordButton component
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify WordButton loads custom images and falls back to icons correctly
    - **Files to Create**: `application/src/components/WordButton.test.tsx` (if not exists)
    - **Files to Modify**: `application/src/components/WordButton.tsx`
    - **Success Criteria**: WordButton displays custom image if available, falls back to Lucide icon if not, lazy loads images for performance
    - **Details**: Modify WordButton to check for `customImageUrl` prop. If present, render `<img>` with src set to base64 data URL, add `loading="lazy"` attribute. If customImageUrl null or image fails to load, render Lucide icon as fallback. Add error handling for image load failures.

- [ ] 7.0 Design image upload UI with preview, crop, and file size warnings
  - **Assigned Agent**: tactical-ux-ui-designer
  - **Context**: Create user-friendly image upload interface with drag-and-drop support, image preview before upload, crop/resize controls, file size warnings, and fallback to Lucide icons if upload fails. This requires UX expertise in file upload patterns and accessibility for users with varying abilities.

  **Sub-Tasks**:

  - [ ] 7.1 Install drag-and-drop and image crop dependencies
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write test to verify libraries import correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/package.json` (add react-dropzone@^14.0.0, react-image-crop@^11.0.0)
    - **Success Criteria**: Libraries install successfully and can be imported
    - **Details**: Install `react-dropzone` for drag-and-drop file upload and `react-image-crop` for image cropping UI. These are standard React libraries for image upload workflows.

  - [ ] 7.2 Design drag-and-drop upload zone with visual feedback
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write component tests to verify dropzone accepts files and shows visual states
    - **Files to Create**: `application/src/components/ImageUploader.tsx`, `application/src/components/ImageUploader.test.tsx`
    - **Files to Modify**: None
    - **Success Criteria**: Dropzone shows clear "drag here or click to upload" state, highlights on drag-over, accepts dropped files
    - **Details**: Create ImageUploader component using react-dropzone. Display dashed border dropzone with upload icon (Lucide Upload) and text "Drag image here or click to browse". Show blue highlight on drag-over. Accept PNG, JPG, WebP, SVG files only. Max 1MB file size with validation error message.

  - [ ] 7.3 Implement image preview with file size display
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify preview displays uploaded image and shows file size
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImageUploader.tsx`, `application/src/components/ImageUploader.test.tsx`
    - **Success Criteria**: Preview shows uploaded image immediately, displays file size (e.g., "450 KB"), warns if >500KB
    - **Details**: After file selected, display image preview using FileReader. Show file size below preview. If size >500KB, show warning badge: "⚠️ Large file - will be compressed to ~500KB". If size >1MB, show error: "❌ File too large - max 1MB".

  - [ ] 7.4 Integrate image crop/resize controls
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify crop tool updates preview and exports cropped image
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImageUploader.tsx`, `application/src/components/ImageUploader.test.tsx`
    - **Success Criteria**: Crop tool allows selecting square region, updates preview in real-time, exports cropped image
    - **Details**: Use react-image-crop to add crop overlay to preview. Constrain to square aspect ratio (1:1) for word buttons. Show real-time preview of cropped area. Provide "Apply Crop" button that generates new File object with cropped image.

  - [ ] 7.5 Design compression preview with before/after comparison
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify compression preview shows size reduction correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImageUploader.tsx`, `application/src/components/ImageUploader.test.tsx`
    - **Success Criteria**: Shows "Before: 850 KB → After: 480 KB" comparison, user can accept or cancel compression
    - **Details**: After crop (if applicable), automatically run compression if file >500KB. Display before/after file sizes. Show side-by-side or overlay preview of original vs compressed image. Provide "Use Compressed" and "Use Original" buttons. Default to compressed version.

  - [ ] 7.6 Integrate ImageUploader into Edit Words screen for word customization
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write integration tests to verify image upload saves to word record
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/settings/EditWordsScreen.tsx`, `application/src/components/AddWordDialog.tsx`, `application/src/components/EditableWordButton.tsx`
    - **Success Criteria**: ImageUploader appears in word edit dialog, uploaded image saves to word, preview updates immediately
    - **Details**: Add ImageUploader to AddWordDialog and EditableWordButton. When image uploaded and processed, call `dataService.updateWord(wordId, { customImageUrl: base64String })`. Show uploaded image preview in dialog. Provide "Remove Image" button to revert to Lucide icon.

### Phase 1D: Import/Export Functionality (Week 3)

- [ ] 8.0 Implement vocabulary export to JSON with metadata and validation
  - **Assigned Agent**: tactical-software-engineer
  - **Context**: Build export functionality that generates structured JSON files containing all vocabulary data (words, categories, settings, custom images, resources) with metadata (app version, export date, statistics). This requires understanding of JSON serialization, file download APIs, and data integrity considerations for backup/restore workflows.

  **Sub-Tasks**:

  - [ ] 8.1 Define JSON export schema with version and metadata
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify export schema matches specification and includes all required fields
    - **Files to Create**: `application/src/lib/utils/exportSchema.ts`, `application/src/lib/utils/exportSchema.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Export schema defined with TypeScript interface, includes version field, metadata section, data section
    - **Details**: Define `ExportData` interface with fields: `version` (schema version, start with "1.0"), `exportedAt` (ISO timestamp), `metadata` (app version, word count, category count, total size), `data` (words array, categories array, settings object, resources array). Document schema in comments.

  - [ ] 8.2 Implement export service to serialize all vocabulary data to JSON
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify export includes all data and produces valid JSON
    - **Files to Create**: `application/src/lib/utils/exportService.ts`, `application/src/lib/utils/exportService.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Export service fetches all data from IndexedDB, serializes to JSON, includes metadata correctly
    - **Details**: Implement `exportVocabulary(): Promise<ExportData>` that calls dataService to get all words, categories, settings, resources. Construct ExportData object with current timestamp, metadata (counts, app version from package.json). Return typed ExportData object.

  - [ ] 8.3 Implement JSON file download with proper filename
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify download triggers browser save dialog with correct filename
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/exportService.ts`, `application/src/lib/utils/exportService.test.ts`
    - **Success Criteria**: Export triggers file download with filename format "aac-vocabulary-YYYY-MM-DD.json"
    - **Details**: Implement `downloadExport(exportData: ExportData)` that creates Blob from JSON string, generates download link using URL.createObjectURL(), sets filename to `aac-vocabulary-${dateString}.json`, triggers click event, cleans up object URL. Test by mocking download in test environment.

  - [ ] 8.4 Add export validation to ensure data integrity
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify validation catches corrupted or incomplete export data
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/exportService.ts`, `application/src/lib/utils/exportService.test.ts`
    - **Success Criteria**: Validation ensures all required fields present, custom images are valid base64, no data corruption
    - **Details**: Implement `validateExportData(exportData: ExportData): { valid: boolean, errors: string[] }` that checks: (1) all required fields present, (2) version is valid, (3) word/category counts match metadata, (4) custom images are valid base64 or null, (5) no circular category references. Run validation before download.

- [ ] 9.0 Implement vocabulary import with merge strategies and conflict resolution
  - **Assigned Agent**: tactical-software-engineer
  - **Context**: Build import functionality with three merge strategies (Replace All, Merge, Append), JSON validation, error handling, and data migration between schema versions. This is complex logic requiring careful handling of data conflicts, duplicate detection, and user choice preservation.

  **Sub-Tasks**:

  - [ ] 9.1 Implement JSON file upload and parsing with validation
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify upload parses valid JSON and rejects invalid files
    - **Files to Create**: `application/src/lib/utils/importService.ts`, `application/src/lib/utils/importService.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Import service reads JSON file, parses content, validates against export schema, provides error messages for invalid files
    - **Details**: Implement `parseImportFile(file: File): Promise<ExportData>` that reads file using FileReader, parses JSON, validates structure matches ExportData interface. Throws descriptive errors for: invalid JSON syntax, missing required fields, wrong schema version (future-proofing), corrupted data.

  - [ ] 9.2 Implement "Replace All" merge strategy
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify Replace All clears existing data and imports new data completely
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/importService.ts`, `application/src/lib/utils/importService.test.ts`
    - **Success Criteria**: Replace All strategy deletes all existing vocabulary, imports all new data, preserves data integrity
    - **Details**: Implement `importReplaceAll(exportData: ExportData): Promise<void>` that: (1) deletes all existing words, categories, settings, resources using dataService, (2) imports all data from exportData, (3) uses database transaction for atomicity. Test that existing data completely replaced.

  - [ ] 9.3 Implement "Merge" strategy with duplicate detection
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify Merge strategy correctly identifies duplicates and merges data
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/importService.ts`, `application/src/lib/utils/importService.test.ts`
    - **Success Criteria**: Merge strategy keeps existing data, adds new words/categories, updates modified items, detects duplicates by text+type
    - **Details**: Implement `importMerge(exportData: ExportData): Promise<ImportResult>` that: (1) compares import data with existing data, (2) adds words not in existing vocabulary, (3) updates words that exist but have different properties (icon, image, order), (4) skips exact duplicates. Duplicate detection uses word.text + word.type as key. Returns ImportResult with counts: added, updated, skipped.

  - [ ] 9.4 Implement "Append" strategy for adding without modification
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify Append strategy adds new data without modifying existing
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/importService.ts`, `application/src/lib/utils/importService.test.ts`
    - **Success Criteria**: Append strategy adds only new words/categories, never modifies existing data, handles duplicate categories gracefully
    - **Details**: Implement `importAppend(exportData: ExportData): Promise<ImportResult>` that: (1) checks each imported word/category against existing data, (2) adds only if not duplicate (by text+type for words, by name for categories), (3) preserves all existing data unchanged, (4) returns count of items added and skipped.

  - [ ] 9.5 Implement import preview/diff calculation
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify diff calculation correctly identifies additions, modifications, deletions
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/importService.ts`, `application/src/lib/utils/importService.test.ts`
    - **Success Criteria**: Diff preview shows accurate counts of words/categories to be added, modified, removed based on merge strategy
    - **Details**: Implement `calculateImportDiff(exportData: ExportData, strategy: MergeStrategy): Promise<ImportDiff>` that analyzes import data vs existing data and returns: `{ wordsAdded: number, wordsModified: number, wordsRemoved: number, categoriesAdded: number, categoriesModified: number, categoriesRemoved: number }`. Logic varies by strategy (Replace All removes all existing, Merge modifies, Append only adds).

  - [ ] 9.6 Implement schema version migration for future compatibility
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify migration from v1.0 to v1.1 schema (simulated future migration)
    - **Files to Create**: `application/src/lib/utils/schemaMigration.ts`, `application/src/lib/utils/schemaMigration.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Migration framework supports upgrading import data from older schema versions to current version
    - **Details**: Implement `migrateImportData(exportData: ExportData, targetVersion: string): ExportData` that handles schema version upgrades. For now, just handle v1.0 (no-op), but establish pattern for future migrations (e.g., v1.0 → v1.1 might add new fields with defaults). Document migration strategy.

- [ ] 10.0 Design import/export UI with preview and merge strategy selection
  - **Assigned Agent**: tactical-ux-ui-designer
  - **Context**: Create intuitive backup and restore interface in Settings screen with visual diff preview showing changes before import (X words added, Y modified, Z removed), merge strategy selection, progress indicators, and clear error messages. This requires UX skills in presenting complex data operations to non-technical users.

  **Sub-Tasks**:

  - [ ] 10.1 Design export button and download confirmation in Settings screen
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write component tests to verify export button triggers download correctly
    - **Files to Create**: `application/src/components/ImportExportManager.tsx`, `application/src/components/ImportExportManager.test.tsx`
    - **Files to Modify**: `application/src/components/SettingsScreen.tsx` (add "Backup & Restore" section)
    - **Success Criteria**: Export button prominently displayed, click triggers download, success toast confirms export
    - **Details**: Add "Backup & Restore" section to Settings screen. Create "Export Vocabulary" button with download icon (Lucide Download). On click, call exportService.exportVocabulary() then exportService.downloadExport(). Show success toast: "Vocabulary exported successfully" with filename.

  - [ ] 10.2 Design import file picker with drag-and-drop support
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify file picker accepts JSON files and shows validation errors
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImportExportManager.tsx`, `application/src/components/ImportExportManager.test.tsx`
    - **Success Criteria**: File picker accepts .json files only, shows drag-and-drop zone, validates file before proceeding
    - **Details**: Add "Import Vocabulary" button with upload icon (Lucide Upload). On click, open file picker (accept=".json") or show drag-and-drop zone. After file selected, call importService.parseImportFile(). Show error toast if validation fails with specific error message. If valid, proceed to merge strategy selection.

  - [ ] 10.3 Design merge strategy selection dialog with explanations
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify strategy selection displays correctly and passes strategy to import
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImportExportManager.tsx`, `application/src/components/ImportExportManager.test.tsx`
    - **Success Criteria**: Dialog shows 3 strategies with clear descriptions, user can select one, default to "Merge"
    - **Details**: Create dialog with 3 radio options: (1) "Replace All" - "⚠️ Delete all existing vocabulary and replace with imported data", (2) "Merge" - "Keep existing vocabulary, add new words, update modified words", (3) "Append" - "Add new words without modifying any existing vocabulary". Default to "Merge". Show warning icon for "Replace All". Include "Cancel" and "Continue" buttons.

  - [ ] 10.4 Design import preview dialog with diff visualization
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify preview dialog displays diff counts correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImportExportManager.tsx`, `application/src/components/ImportExportManager.test.tsx`
    - **Success Criteria**: Preview dialog shows clear summary of changes (words added/modified/removed, categories added/modified/removed)
    - **Details**: After strategy selection, call importService.calculateImportDiff() and display results in dialog. Show counts with color coding: green for additions ("+X words"), blue for modifications ("~Y words updated"), red for removals ("-Z words removed"). Include "Confirm Import" and "Cancel" buttons. For "Replace All", emphasize deletion count in red.

  - [ ] 10.5 Implement import progress indicator and success/error handling
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify progress indicator appears during import and success/error states display correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/ImportExportManager.tsx`, `application/src/components/ImportExportManager.test.tsx`
    - **Success Criteria**: Progress dialog shows during import, success toast on completion, error dialog on failure with details
    - **Details**: After user confirms import, show progress dialog with spinner and text "Importing vocabulary...". Call appropriate import method (replaceAll/merge/append). On success, dismiss dialog and show success toast with summary: "Import complete: X words added, Y updated". On error, show error dialog with specific error message and "Retry" button.

  - [ ] 10.6 Add "Backup & Restore" section to Settings screen with help text
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify section renders correctly with all components
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/SettingsScreen.tsx`
    - **Success Criteria**: Section clearly labeled, includes help text explaining backup/restore, Export and Import buttons prominently displayed
    - **Details**: Add new section to SettingsScreen titled "Backup & Restore". Include help text: "Export your vocabulary to save a backup, or import vocabulary from a file to restore or merge with your current vocabulary." Render ImportExportManager component. Ensure section is easily discoverable in settings.

### Phase 1E: Offline-First Architecture (Week 4)

- [ ] 11.0 Configure service worker with vite-plugin-pwa for offline caching
  - **Assigned Agent**: tactical-platform-engineer
  - **Context**: Set up Vite PWA plugin to generate service worker for offline caching of app shell (HTML, CSS, JavaScript) and static assets (Lucide icons). This requires understanding of service worker lifecycle, caching strategies (cache-first for static assets, network-first for data), and Vite build configuration. The agent will ensure the app loads and functions fully offline after initial cache.

  **Sub-Tasks**:

  - [ ] 11.1 Install and configure vite-plugin-pwa
    - **Assigned Agent**: tactical-platform-engineer
    - **TDD Requirement**: Write test to verify PWA plugin generates service worker during build
    - **Files to Create**: None
    - **Files to Modify**: `application/package.json` (add vite-plugin-pwa@^0.20.0), `application/vite.config.ts`
    - **Success Criteria**: Plugin installs successfully, generates service worker on build, no build errors
    - **Details**: Install `vite-plugin-pwa`. Add plugin to vite.config.ts with basic configuration. Import `import { VitePWA } from 'vite-plugin-pwa'` and add to plugins array. Verify service worker generated in dist/ folder after `npm run build`.

  - [ ] 11.2 Configure caching strategies for app shell and static assets
    - **Assigned Agent**: tactical-platform-engineer
    - **TDD Requirement**: Write tests to verify service worker caches static assets correctly
    - **Files to Create**: None
    - **Files to Modify**: `application/vite.config.ts`
    - **Success Criteria**: Service worker uses cache-first strategy for static assets, app shell cached on first load
    - **Details**: Configure VitePWA plugin with workbox options: `registerType: 'autoUpdate'`, `includeAssets: ['**/*.{js,css,html,ico,png,svg,woff2}']`, `runtimeCaching` with cache-first strategy for static resources. Ensure app shell (index.html, main JS/CSS bundles) cached. Test by loading app, going offline, and verifying app still loads.

  - [ ] 11.3 Implement service worker registration in application entry point
    - **Assigned Agent**: tactical-platform-engineer
    - **TDD Requirement**: Write test to verify service worker registers correctly on app load
    - **Files to Create**: None
    - **Files to Modify**: `application/src/main.tsx`
    - **Success Criteria**: Service worker registers automatically on app load in production builds, updates detected automatically
    - **Details**: Import and use VitePWA's `registerSW()` helper in main.tsx. Configure for automatic updates: `registerSW({ immediate: true, onNeedRefresh() { /* show update prompt */ }, onOfflineReady() { /* show offline ready message */ } })`. Only register in production builds (not dev mode).

  - [ ] 11.4 Configure manifest.json for PWA installation
    - **Assigned Agent**: tactical-platform-engineer
    - **TDD Requirement**: Write test to verify manifest.json includes all required PWA fields
    - **Files to Create**: None
    - **Files to Modify**: `application/vite.config.ts` (add manifest config to VitePWA plugin)
    - **Success Criteria**: Manifest includes app name, description, icons, theme colors, display mode
    - **Details**: Add manifest configuration to VitePWA plugin: `{ name: 'AAC Communication Board', short_name: 'AAC Board', description: 'Augmentative and Alternative Communication Board', theme_color: '#ffffff', icons: [{ src: 'icon-192.png', sizes: '192x192', type: 'image/png' }, { src: 'icon-512.png', sizes: '512x512', type: 'image/png' }], display: 'standalone', start_url: '/', scope: '/' }`. Ensure icons exist in public/ folder.

  - [ ] 11.5 Test offline functionality and cache invalidation
    - **Assigned Agent**: tactical-platform-engineer
    - **TDD Requirement**: Write integration tests to verify app works fully offline and cache updates on new deploys
    - **Files to Create**: `application/src/lib/pwa/pwa.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: App loads and functions completely offline after initial cache, cache updates automatically on new app versions
    - **Details**: Test workflow: (1) Load app online, (2) Go offline, (3) Refresh page - app should load from cache, (4) Test all IndexedDB operations work offline, (5) Go online with new app version deployed, (6) Verify service worker detects update and prompts user. Document offline limitations (no external API calls work offline, only cached assets and IndexedDB).

- [ ] 12.0 Implement online/offline detection and status indicator UI
  - **Assigned Agent**: tactical-ux-ui-designer
  - **Context**: Create visual indicator for connection status (green "Online" | gray "Offline") in app header with toast notifications on status changes. This requires understanding of Navigator.onLine API, connection state management, and non-intrusive status display that doesn't distract from core communication functionality.

  **Sub-Tasks**:

  - [ ] 12.1 Implement useOnlineStatus hook for connection state management
    - **Assigned Agent**: tactical-software-engineer
    - **TDD Requirement**: Write tests to verify hook detects online/offline state changes correctly
    - **Files to Create**: `application/src/hooks/useOnlineStatus.ts`, `application/src/hooks/useOnlineStatus.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Hook returns current online status (boolean), updates on connection changes, handles navigator.onLine API correctly
    - **Details**: Create React hook that listens to `online` and `offline` window events. Returns `isOnline: boolean` state. Use `useEffect` to add/remove event listeners. Initialize with `navigator.onLine` value. Test by simulating online/offline events in test environment.

  - [ ] 12.2 Design offline status indicator component for app header
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write component tests to verify indicator displays correct state and colors
    - **Files to Create**: `application/src/components/OfflineIndicator.tsx`, `application/src/components/OfflineIndicator.test.tsx`
    - **Files to Modify**: None
    - **Success Criteria**: Indicator shows green dot + "Online" when connected, gray dot + "Offline" when disconnected, subtle and non-intrusive
    - **Details**: Create component that uses `useOnlineStatus` hook. Display small status badge in app header (top-right corner). Online state: green dot (Lucide Circle with fill) + "Online" text in gray. Offline state: gray dot + "Offline" text in gray. Use subtle styling to avoid distraction. Add small fade animation on state changes.

  - [ ] 12.3 Implement connection state change toast notifications
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write tests to verify toast appears on state changes with correct messages
    - **Files to Create**: None
    - **Files to Modify**: `application/src/components/OfflineIndicator.tsx`, `application/src/components/OfflineIndicator.test.tsx`
    - **Success Criteria**: Toast appears when going offline (warning style), toast appears when coming back online (success style)
    - **Details**: Use `useEffect` in OfflineIndicator to watch for online status changes. When status changes to offline, show warning toast: "⚠️ You're offline. Changes will sync when you reconnect." (auto-dismiss after 5s). When status changes to online, show success toast: "✓ You're back online" (auto-dismiss after 3s). Don't show toast on initial mount, only on changes.

  - [ ] 12.4 Integrate OfflineIndicator into app layout
    - **Assigned Agent**: tactical-ux-ui-designer
    - **TDD Requirement**: Write integration test to verify indicator appears in app header
    - **Files to Create**: None
    - **Files to Modify**: `application/src/App.tsx` (add OfflineIndicator to header)
    - **Success Criteria**: Indicator appears consistently in app header across all screens, doesn't interfere with navigation
    - **Details**: Add `<OfflineIndicator />` to App.tsx header/layout component. Position in top-right corner with small margin. Ensure it appears on all screens (Core Board, Category screens, Settings, Resources). Test that indicator doesn't overlap with other UI elements on mobile screens.

### Phase 1F: Security Review & Testing (Week 4)

- [ ] 13.0 Conduct security review of data storage, image handling, and import/export
  - **Assigned Agent**: tactical-cybersecurity
  - **Context**: Perform security audit of IndexedDB storage (origin isolation), custom image upload (file type validation, XSS prevention), JSON import (injection prevention), and service worker configuration. This requires cybersecurity expertise in browser security models, client-side attack vectors, and privacy considerations for sensitive user data. The agent will ensure no vulnerabilities in file handling, data validation, or storage access.

  **Sub-Tasks**:

  - [ ] 13.1 Review IndexedDB storage for origin isolation and data privacy
    - **Assigned Agent**: tactical-cybersecurity
    - **TDD Requirement**: Write security tests to verify IndexedDB data is properly scoped to origin
    - **Files to Create**: `application/src/lib/db/security.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: Verify IndexedDB data isolated by origin, no cross-origin access possible, sensitive data not exposed
    - **Details**: Audit IndexedDB implementation to ensure: (1) database properly scoped to application origin, (2) no sensitive data stored unencrypted (personal health info if added in future), (3) data not accessible from other origins or browser extensions, (4) proper error handling doesn't leak database structure. Document security assumptions and limitations.

  - [ ] 13.2 Audit image upload for file type validation and XSS prevention
    - **Assigned Agent**: tactical-cybersecurity
    - **TDD Requirement**: Write security tests attempting XSS attacks via malicious image uploads
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/imageValidator.test.ts` (add security test cases)
    - **Success Criteria**: Image upload rejects malicious files, base64 rendering doesn't execute scripts, no XSS vectors
    - **Details**: Audit image upload system for: (1) strict MIME type validation (not just file extension), (2) file size limits enforced, (3) SVG files sanitized (remove script tags, event handlers), (4) base64 data URLs properly encoded when rendered, (5) no executable content in images. Test with malicious SVG containing `<script>` tags, HTML in filenames, oversized files.

  - [ ] 13.3 Review JSON import for injection and validation bypass attacks
    - **Assigned Agent**: tactical-cybersecurity
    - **TDD Requirement**: Write security tests attempting injection attacks via malicious JSON imports
    - **Files to Create**: None
    - **Files to Modify**: `application/src/lib/utils/importService.test.ts` (add security test cases)
    - **Success Criteria**: JSON import safely validates and sanitizes all input, no code injection possible, malicious imports rejected
    - **Details**: Audit import service for: (1) JSON parsing uses safe methods (JSON.parse, not eval), (2) schema validation prevents unexpected fields, (3) string inputs properly escaped before rendering, (4) base64 images in import validated same as uploads, (5) circular references handled, (6) prototype pollution prevented. Test with malicious JSON containing: `__proto__` pollution, script tags in text fields, invalid base64, circular category references.

  - [ ] 13.4 Verify service worker configuration security (HTTPS, scope, caching)
    - **Assigned Agent**: tactical-cybersecurity
    - **TDD Requirement**: Write tests to verify service worker only registers on HTTPS
    - **Files to Create**: None
    - **Files to Modify**: `application/vite.config.ts` (ensure HTTPS requirement enforced)
    - **Success Criteria**: Service worker only works on HTTPS (or localhost), scope properly restricted, cached data doesn't leak sensitive info
    - **Details**: Audit service worker configuration for: (1) HTTPS-only in production (HTTP allowed only on localhost for dev), (2) service worker scope limited to application origin, (3) cached resources don't include sensitive data, (4) cache invalidation works correctly on updates, (5) no malicious cache poisoning vectors. Document that service workers require HTTPS in production.

  - [ ] 13.5 Conduct penetration testing simulation and document findings
    - **Assigned Agent**: tactical-cybersecurity
    - **TDD Requirement**: Write comprehensive security test suite covering all identified attack vectors
    - **Files to Create**: `application/docs/SECURITY.md` (security documentation), `application/src/tests/security/penetration.test.ts`
    - **Files to Modify**: None
    - **Success Criteria**: All identified security issues documented, mitigations implemented, security test suite passes
    - **Details**: Perform manual penetration testing covering: (1) XSS attempts via image uploads and text inputs, (2) JSON injection in imports, (3) IndexedDB access from devtools (expected behavior - document in SECURITY.md), (4) service worker manipulation attempts, (5) cache poisoning, (6) data exfiltration attempts. Document findings in SECURITY.md with mitigation strategies. Create automated security test suite that runs with `npm test`.

  - [ ] 13.6 Create security documentation and user privacy statement
    - **Assigned Agent**: tactical-cybersecurity
    - **TDD Requirement**: No test required - documentation task
    - **Files to Create**: `application/docs/PRIVACY.md`
    - **Files to Modify**: `application/docs/SECURITY.md` (add user-facing security information)
    - **Success Criteria**: Clear documentation of data storage, privacy guarantees, and security limitations
    - **Details**: Create user-facing privacy documentation covering: (1) all data stored locally in browser (IndexedDB), (2) no data sent to external servers, (3) data persists only on current device/browser, (4) clearing browser data removes all vocabulary, (5) export files contain all vocabulary in plain text (users should secure backups), (6) recommendations for keeping backups safe. Add to app Settings screen as "Privacy & Security" section with link to full documentation.

---

## Success Criteria

**Phase 1A (IndexedDB Foundation)**:
- [ ] IndexedDB database initializes successfully on first load
- [ ] Baseline vocabulary (139 words, 7 categories) seeds correctly
- [ ] All CRUD operations complete in <100ms for typical vocabularies
- [ ] Data persists correctly across browser refresh
- [ ] Migration service handles schema versioning

**Phase 1B (Unlimited Vocabulary)**:
- [ ] Users can add unlimited words to any category
- [ ] Users can create unlimited custom categories
- [ ] Words can be reordered within categories
- [ ] Performance remains acceptable with 500+ words (<200ms operations)
- [ ] Category hierarchy supports up to 3 levels

**Phase 1C (Custom Images)**:
- [ ] Users can upload PNG, JPG, WebP, SVG images (max 1MB)
- [ ] Images compress to <500KB when possible
- [ ] Custom images store in IndexedDB as base64
- [ ] Images lazy load in WordButton components
- [ ] Fallback to Lucide icons if image fails

**Phase 1D (Import/Export)**:
- [ ] Export generates valid JSON with all vocabulary data and metadata
- [ ] Import validates JSON structure with clear error messages
- [ ] All three merge strategies (Replace, Merge, Append) work correctly
- [ ] Round-trip export → import preserves all data
- [ ] Import preview shows accurate diff (added/modified/removed)

**Phase 1E (Offline Support)**:
- [ ] App loads and functions fully offline after initial cache
- [ ] Service worker caches app shell and static assets
- [ ] Online/offline status indicator updates correctly
- [ ] Zero functional degradation when offline
- [ ] Connection state changes trigger toast notifications

**Phase 1F (Security)**:
- [ ] No XSS vulnerabilities in image upload or display
- [ ] No injection vulnerabilities in JSON import
- [ ] IndexedDB data properly origin-scoped
- [ ] File type validation prevents malicious uploads
- [ ] Service worker HTTPS requirement enforced

---

## Next Steps

Once parent tasks are confirmed, sub-tasks will be generated for each phase with specific implementation details, file modifications, test requirements, and success criteria.

**Phase 1: Parent Tasks Generated** ✓

**Phase 2: Awaiting User Confirmation to Generate Sub-Tasks**
